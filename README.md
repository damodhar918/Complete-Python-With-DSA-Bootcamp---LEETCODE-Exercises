# Complete Python With DSA Bootcamp + LEETCODE Exercises

A comprehensive collection of **167+ Data Structures & Algorithms exercises** organized by topic, with multiple implementations, test cases, and complexity analysis for each problem.

## üìö Overview

This repository contains **24 Jupyter notebooks** covering fundamental to advanced DSA topics, including:
- Pattern printing and mathematical concepts
- Data structures (arrays, strings, linked lists, stacks, trees, graphs, hash tables)
- Searching and sorting algorithms
- Dynamic programming
- Object-oriented programming
- Graph algorithms and advanced techniques

## üéØ Learning Path

### **Phase 1: Fundamentals (Notebooks 01-11) - Exercises 1-85**

#### Notebook 01: Pattern Printing
- **Topics**: Stars patterns, number pyramids, hollow shapes
- **Exercises**: 1-5
- **Skills**: Loop control, nested iteration

#### Notebook 02: Math Calculations
- **Topics**: Prime numbers, factorials, Fibonacci, GCD, LCM
- **Exercises**: 6-15
- **Skills**: Number theory basics

#### Notebook 03: Data Structures
- **Topics**: Lists, tuples, dictionaries, sets basics
- **Exercises**: 16-25
- **Skills**: Python built-in collections

#### Notebook 04: Number Theory
- **Topics**: Armstrong numbers, perfect numbers, digit manipulation
- **Exercises**: 26-35
- **Skills**: Number properties, digit operations

#### Notebook 05: String Exercises
- **Topics**: String manipulation, palindromes, anagrams, substrings
- **Exercises**: 36-45
- **Skills**: String methods, pattern matching

#### Notebook 06: Searching and Sorting
- **Topics**: Linear search, binary search, bubble sort, merge sort, quick sort
- **Exercises**: 46-55
- **Skills**: Search algorithms, sorting techniques

#### Notebook 07: Advanced Searching
- **Topics**: Binary search variants, ternary search, rotated arrays
- **Exercises**: 56-65
- **Skills**: Advanced search patterns

#### Notebook 08: Array Manipulation
- **Topics**: Rotation, reversal, subset generation, permutations
- **Exercises**: 66-75
- **Skills**: Array transformations

#### Notebook 09: Matrix Operations
- **Topics**: Matrix traversal, rotation, transposition, spiral patterns
- **Exercises**: 76-85
- **Skills**: 2D array operations

#### Notebook 10: OOP Exercises
- **Topics**: Classes, inheritance, polymorphism, encapsulation
- **Exercises**: (integrated throughout)
- **Skills**: Object-oriented design

### **Phase 2: Recursion & Advanced Data Structures (Notebooks 12-22) - Exercises 86-155**

#### Notebook 12: Basic Recursion
- **Topics**: Factorial, Fibonacci, power calculations, digit sum
- **Exercises**: 86-91
- **Skills**: Base cases, recursive thinking

#### Notebook 13: Recursion on Arrays
- **Topics**: Array search, sorting, subset generation
- **Exercises**: 92-97
- **Skills**: Recursive array operations

#### Notebook 14: Advanced Recursion & Search/Sort
- **Topics**: Binary search, merge sort, quick sort via recursion
- **Exercises**: 98-100
- **Skills**: Divide-and-conquer algorithms

#### Notebook 15: String Recursion
- **Topics**: Palindrome check, reverse, subsequences, permutations
- **Exercises**: 101-103
- **Skills**: Recursive string operations

#### Notebook 16: Linked List Recursion
- **Topics**: Recursive linked list operations, reversal
- **Exercises**: 104-107
- **Skills**: Pointer manipulation via recursion

#### Notebook 17: Advanced Linked List
- **Topics**: Cycle detection, merge, reorder, skip operations
- **Exercises**: 108-114
- **Skills**: Complex linked list problems

#### Notebook 18: Stack Exercises
- **Topics**: Parentheses matching, monotonic stacks, next greater element
- **Exercises**: 115-122
- **Skills**: Stack-based algorithms

#### Notebook 19: Binary Tree Exercises
- **Topics**: Traversals (in/pre/post/level-order), path sum, diameter
- **Exercises**: 123-131
- **Skills**: Tree traversal patterns

#### Notebook 20: BST Exercises
- **Topics**: Search, insertion, deletion, successor, recovery
- **Exercises**: 132-136
- **Skills**: Binary search tree operations

#### Notebook 21: Array & Hash Table Exercises
- **Topics**: Frequency counting, anagrams, two-pointer, hashing
- **Exercises**: 137-142
- **Skills**: Hash-based optimization

#### Notebook 22: Graph Exercises
- **Topics**: Representations, DFS, BFS, connectivity
- **Exercises**: 143-145
- **Skills**: Basic graph algorithms

#### Notebook 23: Graph Advanced Exercises
- **Topics**: Topological sort, cycle detection, paths, components
- **Exercises**: 146-155
- **Skills**: Advanced graph algorithms

### **Phase 3: Dynamic Programming (Notebook 24) - Exercises 156-167**

#### Notebook 24: Dynamic Programming
- **Topics**: 1D DP (LIS, stock, tribonacci, climbing), 2D DP (paths, triangle, falling sum)
- **Exercises**: 156-167
- **Skills**: 
  - Memoization (top-down)
  - Tabulation (bottom-up)
  - Space optimization
  - Recurrence relations

## üìä Exercise Summary by Category

| Category | Notebooks | Exercises | Topics |
|----------|-----------|-----------|--------|
| **Fundamentals** | 01-11 | 1-85 | Patterns, Math, Data Structures, Strings, Search, Sort, Arrays, Matrices |
| **Recursion** | 12-16 | 86-107 | Basic, Arrays, Strings, Linked Lists, Divide-and-Conquer |
| **Data Structures** | 17-21 | 108-142 | Linked Lists, Stacks, Trees, BSTs, Hash Tables |
| **Graphs** | 22-23 | 143-155 | DFS/BFS, Connectivity, Topological Sort, Cycle Detection |
| **Dynamic Programming** | 24 | 156-167 | 1D DP, 2D DP, Path Optimization, Sequence Problems |
| **Total** | **24** | **167+** | **All Major DSA Topics** |

## üîß Features

### Code Quality
‚úÖ **Multiple Implementations**: Each problem includes 2-3 different approaches  
‚úÖ **Test Cases**: Comprehensive test coverage with expected outputs  
‚úÖ **Complexity Analysis**: Time and space complexity for all solutions  
‚úÖ **Algorithm Traces**: Step-by-step execution traces for understanding  
‚úÖ **Edge Cases**: Careful handling of boundary and edge case scenarios  

### Learning Resources
üìñ **Detailed Explanations**: Algorithm concepts and intuitions  
üéØ **Progression**: Systematic difficulty increase within each topic  
üí° **Patterns**: Common algorithm patterns highlighted  
üîç **Optimization**: Space and time optimization techniques shown  

## üöÄ Getting Started

### Prerequisites
- Python 3.8+
- Jupyter Notebook
- Basic understanding of Python syntax

### Installation
```bash
# Clone the repository
git clone <repository-url>
cd Complete-Python-With-DSA-Bootcamp---LEETCODE-Exercises

# Install Jupyter (if not already installed)
pip install jupyter notebook

# Launch Jupyter
jupyter notebook
```

### Usage
1. Open any notebook from the list above
2. Each notebook is self-contained with:
   - Markdown introduction explaining the topic
   - Foundation code (helper functions, classes)
   - Individual exercise cells with multiple solutions
   - Test cases demonstrating correctness
   - Summary comparing all approaches

## üìö Topic-Wise Exercise Breakdown

### Data Structures
| DS | Notebooks | Exercises | Key Topics |
|----|-----------|-----------|-----------|
| **Arrays** | 08, 13, 21 | 66-75, 92-97, 137-142 | Manipulation, Searching, Hashing |
| **Strings** | 05, 15 | 36-45, 101-103 | Pattern, Recursion, Permutations |
| **Linked Lists** | 16, 17 | 104-114 | Recursion, Cycles, Operations |
| **Stacks** | 18 | 115-122 | Matching, Monotonic, Next Greater |
| **Trees** | 19, 20 | 123-136 | Traversal, BST, Paths |
| **Graphs** | 22, 23 | 143-155 | DFS/BFS, Topological, Components |
| **Hash Tables** | 21 | 137-142 | Frequency, Anagrams, Duplicates |

### Algorithm Techniques
| Technique | Notebooks | Exercises | Complexity |
|-----------|-----------|-----------|-----------|
| **Search** | 06, 07 | 46-65 | O(log n) to O(n) |
| **Sort** | 06, 14 | 46-100 | O(n log n) typical |
| **Recursion** | 12-16 | 86-107 | Varies |
| **Dynamic Programming** | 24 | 156-167 | O(n) to O(n¬≤) |
| **Graphs** | 22, 23 | 143-155 | O(V+E) typical |

## üíª Code Examples

### Simple Example: Linear Search (Exercise 46)
```python
def linear_search(arr, target):
    """Find target in array - O(n) time, O(1) space"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

# Test
print(linear_search([1, 3, 5, 7], 5))  # Output: 2
```

### Intermediate Example: Binary Tree Traversal (Exercise 123)
```python
def inorder_traversal(node):
    """In-order: Left, Node, Right"""
    if node is None:
        return []
    return (inorder_traversal(node.left) + 
            [node.val] + 
            inorder_traversal(node.right))
```

### Advanced Example: Longest Increasing Subsequence (Exercise 156)
```python
def longest_increasing_subsequence(arr):
    """DP approach - O(n¬≤) time, O(n) space"""
    dp = [1] * len(arr)
    for i in range(len(arr)):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

## üéì Learning Objectives

By working through these exercises, you will master:

### Core DSA Concepts
- ‚úì Time and space complexity analysis
- ‚úì Data structure design and usage
- ‚úì Algorithm optimization techniques
- ‚úì Recursion and backtracking
- ‚úì Dynamic programming patterns

### Problem-Solving Skills
- ‚úì Identifying optimal approaches
- ‚úì Edge case handling
- ‚úì Code optimization
- ‚úì Testing and validation
- ‚úì Complexity trade-offs

### Advanced Topics
- ‚úì Graph algorithms (DFS, BFS, topological sort)
- ‚úì Tree traversal and manipulation
- ‚úì Dynamic programming optimization
- ‚úì Cycle detection and connectivity
- ‚úì Advanced data structure operations

## üìà Difficulty Progression

```
Beginner (Exercises 1-50)
    ‚Üì
    Patterns, basic math, simple data structure operations
    ‚Üì
Intermediate (Exercises 51-120)
    ‚Üì
    Recursion, trees, stacks, linked lists
    ‚Üì
Advanced (Exercises 121-155)
    ‚Üì
    Complex trees, graphs, topological sorting
    ‚Üì
Expert (Exercises 156-167)
    ‚Üì
    Dynamic programming, optimization problems
```

## üîë Key Patterns to Master

### Algorithm Patterns
1. **Two Pointers**: Fast/slow pointers, partition logic
2. **Sliding Window**: Subarray/substring optimization
3. **Binary Search**: Search space reduction
4. **DFS/BFS**: Graph traversal and exploration
5. **Divide & Conquer**: Recursive problem decomposition
6. **Greedy**: Optimal local choices
7. **Dynamic Programming**: Overlapping subproblems, optimal substructure
8. **Backtracking**: Explore all possibilities with pruning

### Data Structure Patterns
1. **Monotonic Stacks**: Next/previous greater element
2. **Hash Maps**: Frequency counting, deduplication
3. **Trees**: In-order, pre-order, post-order traversal
4. **Graphs**: DFS, BFS, topological sort
5. **Union-Find**: Connected components, cycle detection

## üéØ Practice Strategy

### Day 1-3: Fundamentals
- Start with Notebooks 01-03
- Focus on pattern printing and basic operations
- Complete exercises sequentially

### Day 4-7: Data Structures Basics
- Work through Notebooks 04-06
- Master arrays, strings, and sorting
- Implement algorithms from scratch

### Day 8-14: Recursion & Advanced Structures
- Complete Notebooks 12-18
- Practice recursive thinking
- Build familiarity with linked lists and stacks

### Day 15-20: Trees & Graphs
- Work through Notebooks 19-23
- Master tree traversals
- Understand graph algorithms

### Day 21-30: Dynamic Programming & Review
- Complete Notebook 24
- Review difficult concepts
- Practice mixed problem solving

## üìù Notes

### Optimization Tips
- **Space-Time Tradeoffs**: Many problems have optimized space versions
- **Multiple Approaches**: Compare bruteforce, optimized, and clever solutions
- **Pattern Recognition**: Identify similar problem structures
- **Complexity Analysis**: Always consider both time and space

### Common Pitfalls
- ‚ö†Ô∏è Off-by-one errors in array indexing
- ‚ö†Ô∏è Incorrect base cases in recursion
- ‚ö†Ô∏è Not handling edge cases (empty input, single element, etc.)
- ‚ö†Ô∏è Inefficient algorithms for large inputs

## ü§ù Contributing

To add more exercises or improve existing ones:
1. Follow the notebook structure (introduction, foundation, exercises, summary)
2. Include multiple implementations and test cases
3. Provide complexity analysis for each solution
4. Add algorithm traces for clarity

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

This comprehensive exercise collection is inspired by:
- LeetCode problem library
- GeeksforGeeks tutorials
- Classic DSA textbooks
- Interview preparation resources

## üìû Contact & Support

For questions or suggestions about specific exercises:
1. Review the problem statement and test cases
2. Check the algorithm trace for understanding
3. Compare different implementations
4. Practice the core pattern in isolation

---

**Total Exercises**: 167+  
**Total Notebooks**: 24  
**Estimated Hours**: 100-150 (depending on pace)  
**Difficulty Range**: Beginner ‚Üí Expert  

**Start your DSA mastery journey today! üöÄ**
